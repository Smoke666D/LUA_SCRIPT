--Важно Для редактировани использовать редактор, где можно ставить кодировку UTF-8. 
--При кодировке ANSI ломаются скрипты обработки
init = function() --функция иницализации
        ConfigCan(1,1000);
	-- Функции конфинурации канала. Если не вызвать setOutConfig, то канал будет в режиме DISABLE на урвоне ядра. Т.е. физический будет принудительнов выключен, токи не будет считаться, на команды из скрипта не регаирует.
    setOutConfig(1,45,0,60)  --  Конфигурация выхода  1. номер канала (1-20), 2. номинальный ток (пока еще не определился с верхней границей), 3. время работы в перегузке в мс., 4. ток перегрузки
	OutResetConfig(1,0,1000)    -- Конфигурация режима перегрузки  1. номера канала 2. Кол-во циклов перегрукзи, если 0, то будет пытаться рестартовать бесконечно, если 1, то сразу после перегрузки удейт в ошибку
						     -- если больше 1, то соотвесвенно будет патться стартануть указаное кол-во раз. 3. Таймаут перед новым запускаом при перегузке
							-- Если не вызывать OutResetConfig, по умолчанию канал после пегрузки идет в ошибку.
	-- в ядре есть алгоримт софт-старта. Пока не вытащил его в скрит. Скоро будет.
	setOutConfig(2,20,0,60)
	setOutConfig(3,20,0,60)
	setOutConfig(4,20,0,60)
	OutResetConfig(4,0,1000)	
	setOutConfig(5,20,0,60)
	setOutConfig(6,20,0,60)
	setOutConfig(7,20,0,60)
	setOutConfig(8,20,0,60)
	setOutConfig(9,8,0,10)
	OutResetConfig(9,0,500)
	setOutConfig(10,8,0,10)
	OutResetConfig(10,0,10)
	setOutConfig(11,8,0,10)
	setOutConfig(12,8,0,10)
	setOutConfig(13,10,0,30)
	OutResetConfig(13,0,10)
	setOutConfig(14,8,0,10)
	OutResetConfig(14,0,10)
	setOutConfig(15,8,0,10)
	setOutConfig(16,8,0,10)
	setOutConfig(17,8,0,10)
	setOutConfig(18,8,0,10)
	setOutConfig(19,8,0,10)
	setOutConfig(20,8,0,10)
        setDINConfig(1,1)
        setDINConfig(2,1)
        setDINConfig(3,1)
        setDINConfig(4,1)
        setDINConfig(5,1)
        setDINConfig(6,1)
        setDINConfig(7,1)
        setDINConfig(8,1)
        setDINConfig(9,1)
        setDINConfig(10,1)
        setDINConfig(11,1)
--        SetEEPROM(0x01,0x6743)
--        CAN_EXCHENGE    = CanRequest:new()
--	if ( CAN_EXCHENGE:waitCAN(0x615,0x595,8000,0x2F,0x03,0x20,0x03,0x06,0x00,0x00,0x00) == true) then
--		local dd1,dd2,dd3,dd4,dd5,dd6,dd7,dd8 = CAN_EXCHENGE:getData()
--		if dd1 == 0x60 then
--		        setOut(13,true )
--		end
--	end
end
----
main = function ()


    local KeyBoard		=  KeyPad8:new(0x15)
	local temp_out		= true	
	local temp_out1		= true
	local counter		= 0
	local counter1		= 0
	local Wiper 	        = Wipers:new(2000,3)
	local OUT1		= false

	setOut(4,true)	
	setOut(7,false)
        setOut(10, true )
	setOut(14,true)
	while true do  -- начало рабочего цикла ( цикл может быть любой, хоть do until, хоть for
	-- цикл может быть конечным. Т.е из цикла можно выйти. После этого LUA машина заночит работу и перейдет в безопасный режим,
	-- т.е. выклчюит все выхода. Ну и запуситься токо после перезапуска питания.
	KeyBoard:process()
	KeyBoard:setLedGreen(1,true)
	KeyBoard:setLedGreen(2,true)

			counter = counter + 1
			counter1 = counter1 + 1

			if counter > 1000 then
				counter = 0
				temp_out = not temp_out
		        --        setOut(14, temp_out )
			--	 setOut(9, temp_out)
				KeyBoard:setLedGreen(3,temp_out)
			end
			if counter1 > 50 then
				counter1 = 0
				temp_out1 = not temp_out1
		--	        OutSetPWM(4, temp_out1 and 30 or 90)
--                                setOut(2, temp_out1 )
			end
		-- Работа с аналоговыми входами	и выходами
		-- выключить выход 1 если  напряжение питания меньше 5.5 и включить если больше
		-- через работу с локальной переменной
		if ( getAin (3)  < 10.0 ) then		    
		 	OUT1 = false
		else
			OUT1 = true
		end		
		setOut(13,OUT1)
		setOut(9,OUT1)

	--	setOut(14,OUT1)
	--	setOut(10,OUT1)
		

		-- тоже самое для выхода 2 и AIN1 но напрямую
		if ( getAin( 1 ) < 10.0 ) then
		    setOut(2,false)		 	
		else
		    setOut(2,true)			
		end				
		-- тоже самое для выхода 3 и AIN2 но с фишкой LUA синтаксиса				
		setOut(1, ( getAin( 2 ) > 10.0 ) and true or false )
		-- прикол в том, что оно работает как    (условие) and (возвращаемое значеие если условие true) or (возвращаемое значение если условие false)
		-- и возвращамое начение может быть любым, вклчюая числа. Прикольно же?
		
		
		Yield() -- ключевая функция рабочего цикла. Она 1. Загоняте в ядро новые значения выходов, которые устнавливаются в setOut()
		-- 2. Приостанавливает работу скрипта, что бы ядро могло выполнить сервисные процессы
		-- 3. Загржает новые данные (токи, аины, дискреты)
		-- 4. Продлжает работу скрипта с этого же места.
		-- Исходя из этого, если меняешь значения выхода несколько раз за цикл, реально на выход пойдет последние значение, которе установлено перед тек как вызван Yield
		-- Значения токов и всего остального актуализруется после вызова Yield. Пока это бесполезная инфромация, поскльку я пока не придумал скрипта
		-- перегрузившего систему больше чем на 2 мс. Но чисто в теории, если написать прям какой-то очень тяжелый скрипт, например посчитать какую-то 
		-- лютую формулу, а псоклько в lua все числа хранятсья по факту в float32, при желании изобразить скрипт на 30 мс вполне можно наверное. То
		-- если в процессе расчета этой самой формулы канал уйдет в перегрузку, то ядро отрабоатет по уставкам, но актуальный ток и состояние канала в скритпе будет видно
		--только после вызова Yield()
		-- При этом CAN вызовы работают асинхроно от Yield. Если дать комнду на отправку пакета, то он сразу удйте в ядро. И на прием ядро тоже будет принимать фреймы 
		-- и при чтении пакета с нужным ID будет выдан последний принятый пакет. 
		
	end
end
